# 微前端向导

## 参考资料

[微前端简介](https://www.jianshu.com/p/785c2ca5a886)

## 概念

微前端主要是借鉴后端微服务的概念。简单地说，就是将一个巨无霸（Monolith）的前端工程拆分成一个一个的小工程。别小看这些小工程，它们也是“麻雀虽小，五脏俱全”，完全具备独立的开发、运行能力。整个系统就将由这些小工程协同合作，实现所有页面的展示与交互。

## 难点

1. 多个微前端如何共享数据，子 app 之间的通信
2. 如何按需顺序加载
3. 子 app 的生命周期
4. 路由和加载应用
5. 共享库

开发人员担心微前端架构的一个常见问题是浪费资源，每个前端都导入自己的框架版本。是的，如果开箱即用默认的 bundler，是的，这是一个问题，但这不是一定要解决的。

我个人的建议是使用共享库。这些库已经预先安装在系统上，并且可以由所有 app 导入。这是在将库部署到系统上时可以使用的文件夹结构的示例：

<pre><code class="language-treeview">
root_folder/
├── a first folder/
|   ├── holidays.mov
|   ├── javascript-file.js
|   └── some_picture.jpg
├── documents/
|   ├── spreadsheet.xls
|   ├── manual.pdf
|   ├── document.docx
|   └── presentation.ppt
└── etc.
</code></pre>

```tree -F
libraries/
|-- preact/
|   |-- 8/
|   |-- 10/
|-- components/
|   |-- 1/
|   |-- 2/
```

数字是什么意思？这些是那些库的主要版本。如果一个库遵循 semver，根据定义，如果它具有相同的主版本号，则它是向后兼容的。当应用程序要使用库时，它将指定要使用的主要版本，而不是特定的次要版本和修补程序版本

这种方法的好处：

缓存 - 浏览器缓存更有可能被更好地利用，因为应用程序将引用相同的库文件，而不是必须分别缓存的多个特定版本。
更新 - 使用这种方法，如果三方库中有错误修复稍有更改，要做的就是部署共享仓库的新版本，并且所有应用程序（无需重新编译）将自动使用最新版本，因为它们仅指定主版本。

6. 全局样式

在 spa 中控制全局样式可以使用 less sass 等控制其作用域, 但在微服务的架构中每个子项目都会使用自己的技术偏好,那么如何保证样式的独立性成为了一个问题, 在这里有一个解决方案, 那就是记录子 app 创建的 style 标签在生命周期卸载时, 移除他们, 这样每次在子 app 中互相切换不会互相影响彼此

7. 对性能的影响

   按需加载、公共依赖加载和预加载，是关于性能的，这些很重要，否则虽然上了微前端，但性能严重下降，或者由于升级引起线上故障，就得不偿失了。

## 优点

### 更多的构建

项目规模越大，构建该项目所花费的时间就越长。尽管 Webpack 和 Parcel 之类的打包工具通过使用多个线程和缓存来尽力提高打包的性能，但在我看来，但这没有结局根本问题。即使有了这些性能改进，随着 app 的不断增长，app 构建速度也会逐渐变慢。请记住，没有良好的开发体验，就很难提供良好的用户体验。

通过拆分为几个不同的项目，每个项目都有自己的构建方式，无论您的系统如何增长，每个项目的构建速度都会非常快。集成系统也将从中受益，因为每个项目都可以独立且并行的构建，并最终在最后合在一起。

### 并行开发

通过将拆分为单独的项目，可以让多个团队一起工作。每个团队可以负责系统的一项功能。例如，一个团队可以使用电话功能，而另一个团队可以使用联系人功能。每个团队可以拥有自己的 Git 仓库，并可以在需要时运行带有自己的版本控制和变更日志的部署。

在大多数情况下，这些团队不需要了解彼此的功能。但是，这两个应用程序之间仍然需要集成。每个团队都需要在公共 API 上定义并保证向后兼容。该 API 通常通过使用 URL 来实现(也可以由父容器定义)。

## 微服务化前后端对比

### 后端微服务化的优势：

1. 复杂度可控: 体积小、复杂度低，每个微服务可由一个小规模开发团队完全掌控，易于保持高可维护性和开发效率。
2. 独立部署: 由于微服务具备独立的运行进程，所以每个微服务也可以独立部署。
3. 术选型灵活: 微服务架构下，技术选型是去中心化的。每个团队可以根据自身服务的需求和行业发展的现状，自由选择最适合的技术栈。
4. 容错: 当某一组建发生故障时，在单一进程的传统架构下，故障很有可能在进程内扩散，形成应用全局性的不可用。
5. 扩展: 单块架构应用也可以实现横向扩展，就是将整个应用完整的复制到不同的节点。

### 前端微服务化后的优势:

1. 复杂度可控: 每一个 UI 业务模块由独立的前端团队开发,避免代码巨无霸,保持开发时的高速编译,保持较低的复杂度,便于维护与开发效率。
2. 独立部署: 每一个模块可单独部署,颗粒度可小到单个组件的 UI 独立部署,不对其他模块有任何影响。
3. 技术选型灵活: 也是最具吸引力的,在同一项目下可以使用如今市面上所有前端技术栈,也包括未来的前端技术栈。
4. 容错: 单个模块发生错误,不影响全局。
5. 扩展: 每一个服务可以独立横向扩展以满足业务伸缩性，与资源的不必要消耗；
6. 团队效率：极大避免了 git 冲突问题，每个开发者只要负责自己独立的模块。

## 我们何时需要前端微服务化?

1. 项目技术栈过于老旧,相关技能的开发人员少,功能扩展吃力,重构成本高,维护成本高.
2. 项目过于庞大,代码编译慢,开发体差,需要一种更高维度的解耦方案.
3. 单一技术栈无法满足你的业务需求

## 其中面临的问题与挑战

我们即将面临以下问题:

- 我们如何实现在一个页面里渲染多种技术栈?
- 不同技术栈的独立模块之间如何通讯?
- 如何通过路由渲染到正确的模块?
- 在不同技术栈之间的路由该如何正确触发?
- 项目代码别切割之后,通过何种方式合并到一起?
- 我们的每一个模块项目如何打包?
- 前端微服务化后我们该如何编写我们的代码?
- 独立团队之间该如何协作?

## Single-SPA

使用 Single-SPA 之后,你可以这样做:

- (兼容各种技术栈)在同一个页面中使用多种技术框架(React, Vue, AngularJS, Angular, Ember 等任意技术框架),并且不需要刷新页面.
- (无需重构现有代码)使用新的技术框架编写代码,现有项目中的代码无需重构.
- (更优的性能)每个独立模块的代码可做到按需加载,不浪费额外资源.
- 每个独立模块可独立运行.
